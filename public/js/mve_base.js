// Generated by CoffeeScript 1.7.1

/*


Development guidelines



- use options.elements for elements
 */

(function() {
  var disableEvent, mve;

  mve = window.mve || {};

  window.mve = mve;

  mve.mustachePath = 'mustache/';

  mve.mustacheFor = function(fileNameNoExt) {
    return this.mustachePath + fileNameNoExt + '.mustache';
  };

  disableEvent = function(ev) {
    ev.preventDefault();
    return ev.stopPropagation();
  };

  mve.disableEvent = disableEvent;

  mve.timeInMinsSeconds = function(timeInSeconds) {
    var mins, seconds;
    mins = Math.floor(timeInSeconds / 60);
    seconds = timeInSeconds % 60;
    seconds = Math.round(seconds * 100) / 100;
    if (seconds < 10) {
      seconds = "0" + seconds;
    }
    return mins + " : " + seconds;
  };

  mve.timeInHoursMinsSeconds = function(timeInSeconds) {
    var hours, mins, seconds;
    if (typeof timeInSeconds === "function") {
      timeInSeconds = timeInSeconds();
    }
    if (typeof timeInSeconds === "string") {
      return timeInSeconds;
    }
    hours = Math.floor(timeInSeconds / 60 / 60);
    mins = Math.floor(timeInSeconds / 60);
    seconds = timeInSeconds % 60;
    seconds = Math.round(seconds * 100) / 100;
    if (seconds < 10) {
      seconds = "0" + seconds;
    }
    if (hours === 0) {
      return mins + " : " + seconds;
    } else {
      if (mins < 10) {
        mins = "0" + mins;
      }
      return hours + ":" + mins + " : " + seconds;
    }
  };

  mve.DeadPixel = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

  mve.PS = {
    UNSTARTED: -1,
    ENDED: 0,
    PLAYING: 1,
    PAUSED: 2,
    BUFFERING: 3,
    VIDEO_CUED: 5
  };

  mve.MVEPlayerApp = can.Control.extend({
    defaults: {
      template: mve.mustacheFor('mve_player'),
      iframeSelector: 'player',
      iframeWrapSelector: '.player-wrap',
      vidWidth: 1080,
      vidHeight: 558,
      videoId: "CGyEd0aKWZE",
      autoplay: 0,
      controls: 0,
      ytplayer: void 0
    }
  }, {
    init: function(element, options) {
      var handleData, helpers, viewData, _this;
      if (window.MVE != null) {
        console.error("There should only be one MVEPlayerApp");
        console.error("i'm not building for two in the same page");
        return;
      }
      window.MVE = this;
      viewData = new can.Map();
      _this = this;
      this.setupAllStates();
      this.duration = void 0;
      this.playerIntervalId = void 0;
      this.PLAYER_INTERVAL_TIME = 100;
      this.options.globalCurrentTime = can.compute(0);
      this.useHighestQuality = false;
      this.qualityLevels = new can.List();
      viewData.attr('qualityLevels', this.qualityLevels);
      this.youtubeAPILoaded = can.compute(false);
      this.options.playerState = can.compute(mve.PS.UNSTARTED);
      helpers = {
        "formattedTime": mve.timeInHoursMinsSeconds
      };
      viewData.attr('deadPixel', mve.DeadPixel);
      this.element.html(can.view(this.options.template, viewData, helpers));
      this.playerWrap = this.element.find('.player-wrap');
      handleData = {
        time: -1,
        left: -1,
        selected: false,
        show: false
      };
      this.options.startHandleData = new can.Map(handleData);
      this.options.endHandleData = new can.Map(handleData);
      viewData.attr('startHandleData', this.options.startHandleData);
      viewData.attr('endHandleData', this.options.endHandleData);
      this.options.handleMiddle = new can.Map({
        left: false,
        width: false,
        show: false
      });
      viewData.attr('handleMiddle', this.options.handleMiddle);
      this.movements = new mve.Movement.List(mve.Movement.devMovements);
      viewData.attr('movements', this.movements);
      this.timeControls = new mve.MVE_TimeControls(this.element, {
        viewData: viewData,
        app: _this
      });
      this.sliderControls = new mve.MVE_SliderControls(this.element, {
        viewData: viewData,
        app: _this
      });
      this.movementControls = new mve.MVE_MovementControls(this.element, {
        viewData: viewData,
        app: _this
      });
      this.controls = [this.sliderControls, this.timeControls, this.movementControls];
      this.on();
      this.setupYoutubeApiReady();
      return this.insertYoutubeApiScript();
    },
    setupYoutubeApiReady: function() {
      var onPlayerReady, onPlayerStateChange, player, _this;
      player = {};
      this.player = player;
      _this = this;
      onPlayerReady = function(event) {
        return _this.onPlayerReady();
      };
      onPlayerStateChange = function(event) {
        return _this.changePlayerState(event.data);
      };
      return window.onYouTubeIframeAPIReady = function() {
        return _this.player = new YT.Player('player', {
          height: _this.options.vidHeight,
          width: _this.options.vidWidth,
          videoId: _this.options.videoId,
          playerVars: {
            controls: _this.options.controls,
            autoplay: _this.options.autoplay
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange
          }
        });
      };
    },
    insertYoutubeApiScript: function() {
      var firstScriptTag, tag;
      tag = document.createElement('script');
      tag.src = "js/youtube_api.js";
      firstScriptTag = document.getElementsByTagName('script')[0];
      return firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    },
    onPlayerReady: function() {
      var control, _i, _len, _ref, _results, _this;
      this.player.playVideo();
      this.youtubeAPILoaded(true);
      window.player = this.player;
      this.duration = this.player.getDuration();
      this.player.mute();
      _this = this;
      this.playerIntervalId = setInterval(this.playerInterval, this.PLAYER_INTERVAL_TIME, _this);
      _ref = this.controls;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        control = _ref[_i];
        _results.push(control.onPlayerReady());
      }
      return _results;
    },
    setQualityRate: function() {
      var highestQuality, lowestQuality;
      if (!this.qualityLevels.attr('length')) {
        this.qualityLevels.replace(this.player.getAvailableQualityLevels());
        if (this.useHighestQuality) {
          highestQuality = this.qualityLevels[0];
          return this.player.setPlaybackQuality(highestQuality);
        } else {
          lowestQuality = this.qualityLevels.attr(this.qualityLevels.attr('length') - 2);
          return this.player.setPlaybackQuality(lowestQuality);
        }
      }
    },
    changePlayerState: function(newState) {
      return this.options.playerState(newState);
    },
    playerInterval: function(_this) {
      var control, _i, _len, _ref, _results;
      if (!_this.youtubeAPILoaded()) {
        return;
      }
      _this.options.globalCurrentTime(_this.player.getCurrentTime());
      _ref = _this.controls;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        control = _ref[_i];
        _results.push(control.onPlayerInterval());
      }
      return _results;
    },
    "{playerState} change": function(playerState, ev, newVal, oldVal) {
      var control, _i, _len, _ref, _results;
      this.setQualityRate();
      _ref = this.controls;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        control = _ref[_i];
        _results.push(control.onPlayerStateChange(newVal, oldVal));
      }
      return _results;
    },
    ".flip-icon click": function(el, ev) {
      return this.playerWrap.toggleClass('flipped');
    },
    loadNewPlayer: function() {
      return this.player.loadVideoById(this.options.videoId);
    },
    getAspectRatio: function() {
      return 16 / 9;
    },
    setupAllStates: function() {},
    setupState: function(states) {
      var key, obj, _results;
      _results = [];
      for (key in states) {
        obj = states[key];
        states[key].name = key;
        if (!states[key].enter) {
          states[key].enter = function() {
            return jQuery.Deferred().resolve();
          };
        }
        if (!states[key].leave) {
          _results.push(states[key].leave = function() {
            return jQuery.Deferred().resolve();
          });
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    handleStateChange: function(_this, newState, oldState) {
      console.log({
        newState: newState.name,
        oldState: oldState.name
      });
      return oldState.leave(_this).done(function() {
        return newState.enter(_this).done(function() {});
      });
    }

    /*
    
    	This needs to be a good thing that works well
    	I basically need a bunch of mini states which make it impossible for
    	them to interfere with each other
    
    	for example,if I am in edit mode and I want to go into play mode
    		that doesn't bother me
    
    		I alsow want plugins to be able to have their own state machienes
    		which are taken into consideration by the larger state machine manager 
    		inside the app
    
    		I also don't like editing a big ass state machine so I want sub state machines
    		that all work perfectly fine together
    
    
    		app.setCurrentState(afsd)
    
    		if enter state si called
    			leavecurrentstae.done()
    
    
    		leavecurrentstate: ->
    			if new state.superstate is a different superstate
    				return prev state.superstate.leave
    			else 
    				return 
    
    		superstate.leave() ->
    			leave the particular inner state
    			reset the superstate to its starting position
     */
  });

}).call(this);
